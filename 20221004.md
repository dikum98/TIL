## 8번

Nav.js와 NewsList.js에서 네비게이션 컴포넌트와 뉴스리스트 컴포넌트를 각각 생성하고, 네비게이션의 변화에 대한 참조를 프록시, 옵저버 패턴을 통해 캐치한다. 아마 리액트에도 프록시, 옵저버 패턴의 개념이 녹아있지 않을까 싶다.

무한 스크롤 구현을 할 때 intersectionObserver를 통해 스크롤 된 정도를 감지해서 언제 뉴스 API를 가져올지 정할 수 있다.

### 무한 스크롤 관련

스크롤을 아래로 내려서 뉴스 api를 새로 받아올 때 두 번씩 받아오는 문제 발생. 

intersectionObserver의 콜백함수의 매개변수에 entries를 받아서 intersectionRatio로 관찰 노드가 화면에 보이는 비율을 가져올 수 있다. 이 비율이 0일 때 즉, 스피너가 화면에 하나도 보이지 않을 때는 isLoading을 false로 준다. (최초 렌더링 때는 스피너 돌아가고 있음)

### intersectionObserver??

intersectionObserver API는 루트 요소와 타겟 요소의 교차점을 비동기로 관찰하면서 콜백함수를 실행할 수 있게 함.

- 기존에 getBoundingClientRect 메서드를 쓸 때는 메인 스레드를 썼기 때문에 성능상 비교적 나빴음
  - 리플로우도 발생시킴
- 사이트는 요소의 교차를 관찰하기 위해 메인 스레드를 사용할 필요가 없어짐. 비동기적으로 실행.
  - 가시성 구분시 리플로우를 발생시키지 않음 → 교차 영역 관리 최적화

콜백을 호출할 수 있는 상황

- 대상 요소가 기기 뷰포트나 특정 요소와 교차할 때
- 옵저버가 최초로 타깃을 관측하도록 요청받을 때마다

## 오늘을 마치며

연휴간 intersectionObserver와 프록시 패턴을 써야하는 8번 문제를 복습했다. 당장 구현에만 급급한 경우 사용하는 API나 라이브러리에 대한 이해를 바탕으로 코드를 짜지 못할 확률이 높다는 걸 느꼈다. 요구사항이 지금처럼 미니 프로젝트 규모라서 조금만 돌아가면 문제 해결이 가능하지만 나중에 규모가 커지게 되면 구현에만 급급하게 될 경우 모래성이 쉽게 무너지고 결국에는 더 오랜 시간이 걸릴 것 같다는 생각이 들었다. 조금이라도 더 내가 쓰는 기술에 대한 이해를 깊게 할 필요를 느꼈다.