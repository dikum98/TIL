# 20220830화

## DOM을 공부하고 느껴야할 것

DOM이 참 불편하구나. 그래서 리액트같은 라이브러리를 써야겠구나.

- DOM이 일관성이 참 없다.
  - textContent, innerText, innerHTML, nodeValue 등

## 이벤트 핸들러 어트리뷰트 방식

이벤트 핸들러 어트리뷰트 방식에서 어트리뷰트 값으로 들어오는 함수 호출문은 “문자열"이다.

- 객체를 넘길 수 없다.
  - 리액트로 하면 {}로 넘기니까 객체 넘길 수 있다. (JSX 문법)
    ```jsx
    <!DOCTYPE html>
    <html>
    <body>
      <button onclick="sayHi('Lee')">Click me!</button>
    위에 이걸 아래처럼 바꾸면 JSX?
      <button onClick={sayHi('Lee')}>Click me!</button>
      <script>
        function sayHi(name) {
          console.log(`Hi! ${name}.`);
        }
      </script>
    </body>
    </html>
    ```

### 이벤트 핸들러 어트리뷰트 방식은 안 좋은가

바닐라 자바스크립트에서는 바람직하지 않다. 하지만 큰 틀에서 CBD 방식으로 보면 옳다.

- 전통적인 관점에서 HTML, CSS, JS는 각각 문법이 다르고 분리된다.
- 현재의 관점은 HTML, CSS, JS는 한 몸이다.
  - 문법은 다르고 분리되어있지만 목적은 동일하다
  - 관심사가 동일하다
    - 컴포넌트를 만든다 (CBD)

전통적 관점에서는 HTML이 대장이었는데, 지금은 JS가 HTML, CSS를 관장한다.

- 리액트에서 HTML 파일을 만들 일이 없다.
  - JS안에서 HTML, CSS 다 작성한다.
  - HTML이 JS안에서 문자열이 되어 존재한다.
    - innerHTML에 할당하는게 문자열임

## 제이쿼리를 쓰지말라는 이유

제이쿼리를 사용하면 자바스크립트가 HTML에 종속된다.

- 자바스크립트 로직은 변화가 없는데 HTML, CSS가 변하게 되는 경우에 문제
  - 디자인이 바뀌었는데 코드에 영향을 주게 됨
    - 테스트를 다시 하게 됨
    - 오류가 발생할 수 있음

아래 $(’h1’)이 querySelector와 같다.

- querySelector가 문제다 HTML에 종속이 되어있다.
- 제이쿼리 쓰지 않아야겠다고 생각했으면 DOM도 사용하면 안 된다.

```jsx
$(function () {
  var title = 'app works!';
  $('h1').text(title);
});
```

최고 좋은 건 디자인이 바뀌더라도 자바스크립트 로직에 변화가 없다는게 확신할 수 있어야 함

HTML이 주도하는 개발 방식에서 JS가 주도하는 개발방식으로 바꿔야 함.

## 자바스크립트에서는 무조건 addEventListener 써라

한 요소에 이벤트리스너 여러개 등록할 일이 의외로 빈번하다.

- 무조건 addEventListener 써야 한다.

---

## 이벤트 객체는 언제 생성되는가

이벤트가 발생하면 이벤트 객체가 생성된다. 이벤트는 언제 발생하는가

- 사용자가 뭔가 했을때
- 페이지가 로드되었을 때
- 커스텀 이벤트의 디스패치가 호출되었을 때 등

## 이벤트 리스너는 뭐 하는 녀석인가?

지정된 이벤트 타입을 가지는 요소 노드들에게 이벤트가 발생하는지 관찰하는 메서드

- 이벤트 타입이 다른 노드의 경우에는 관찰하지 않는다.
- 이벤트 리스너가 걸리지 않은 노드도 관찰하지 않는다.

## 이벤트 전파

이벤트는 상위 노드 → 타깃 → 상위 노드 방향으로 한 바퀴 돌면서 전파된다.

- 캡처링 → 타깃 → 버블링
- 동일한 이벤트 타입을 가지는 요소 노드로만 전파된다.

### stopPropagation이란

stopPropagation은 이벤트 전파를 중지하는 메서드

- 캡처링 단계에서 막히거나
- 버블링 단계에서 막히거나

### 그래서 전파는 어떻게 되는건가

1. 이벤트 타입에 따른 생성자 함수가 호출되어 이벤트 객체가 생성됨
2. 3번째 인수로 phase 있으면 페이즈 검사
   1. false면 이벤트 객체가 버블링 단계에서 캐치된건지를 확인
   2. true면 이벤트 객체가 캡처링 단계에 캐치된건지를 확인

---

## 이벤트 핸들러에서의 this

이벤트 핸들러 내부에서 this 쓰지마라 헷갈린다..

호출자를 참조하고 싶으면 this 쓰지말고 어차피 변수에 담겨있으니까 그냥 호출자 자체를 참조해라

클래스에서도 화살표함수 쓰지말고 그냥 bind 간접호출 해라

---

투두리스트 정도는 코드를 외우고 있어야 한다.

미리 변수에 담지 마라

- 나중에 재사용하게 될 때 그 때 변수를 써라

생각을 해서 코드짜라…

키업을 써라.

- 한글은 조합 문자이기 때문에 keyup을 사용하면 영어와 달리 한글 입력 이슈가 존재한다.

이벤트 타입별로 이벤트 객체의 내용이 다르다.

키보드 누르면 어떤 키가 눌렸는지에 대한 정보를 키보드 이벤트 객체가 담고있다.

얼리리턴 안하면 한 뎁스 더 들어가야되니까 가독성에안좋다.

---

## MVC 패턴

프론트엔드 관점에서 Model, View, Control이란 무엇인지 생각해볼 것

- MVC가 만능은 아니지만 이것을 베이스로 한 것이 많기 때문에 배워야 한다.
  - 쓰지 않더라도 MVC의 장단점을 알아야 다른 패턴을 차용한다.

## 공부는 어떻게가 아니라 왜

어떻게 하지? 보다는 왜 안되지? 또는 왜 되지?를 생각하자
