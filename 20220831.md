# 20220831수

# 40장 이벤트

브라우저는 처리해야 할 특정 사건이 발생하면 이를 감지하여 이벤트를 발생시킨다.

이벤트 핸들러

- 이벤트가 발생했을 때 호출 될 함수

이벤트 핸들러 등록

- 이벤트가 발생했을 때 브라우저에게 이벤트 핸들러의 호출을 위임

## 이벤트 핸들러 등록

세 방식 모두 이벤트 핸들러 내부의 this는 이벤트를 바인딩한 DOM 요소를 가리킨다.

- 즉 이벤트 핸들러 내부의 this는 이벤트 객체의 currentTarget 프로퍼티와 같다.

### 이벤트 핸들러 어트리뷰트

HTML 요소의 어트리뷰트 값으로 함수 호출문을 등록하는 방식.

- 어트리뷰트 자체가 이벤트 핸들러다.
  - 값으로 등록된 함수 호출문은 암묵적으로 생성된 이벤트 핸들러 함수 몸체에서 호출된다.
- 이벤트 객체 이름은 event로 고정
  - 암묵적으로 생성되는 이벤트 핸들러에서 매개변수도 이름이 암묵적으로 명명되기 때문

### 이벤트 핸들러 프로퍼티

요소 노드의 이벤트 핸들러 프로퍼티에 함수를 바인딩하는 방식.

- 함수를 프로퍼티에 할당하는 것이므로 하나의 요소 노드에는 하나의 이벤트 핸들러만 등록 됨
- 이벤트 핸들러를 제거하려면 이벤트 핸들러 프로퍼티에 null을 할당

### addEventListener 메서드

DOM Level2에서 도입된 EventTarget.prototype.addEventListener 메서드 방식

- 매개변수로 이벤트 전파 단계를 지정할 수 있음
  - 기본값 false : 캡처링 생략
  - true : 캡처링 캐치
- 하나 이상의 이벤트 핸들러를 등록할 수 있음
  - addEventListener를 여러번 호출하면 됨
    - 단 참조가 동일한 함수를 등록하면 하나의 이벤트 리스너만 등록 됨
- 임의로 지정한 이벤트 타입의 경우 addEventListener 방식으로만 이벤트 핸들러 등록 가능
  - 앞의 두 등록 방식에서는 on + 이벤트 타입으로 이루어진 이벤트 핸들러 어트리뷰트/프로퍼티가 요소 노드에 존재하지 않기 때문에 addEventListener 방식만 가능
- 이벤트 핸들러의 매개변수에 전달받은 이벤트 객체 이름을 마음대로 정할 수 있음

## 이벤트 핸들러 제거

### addEventListener 메서드로 등록한 이벤트 핸들러 제거

removeEventListener 메서드에 동일한 참조의 이벤트 핸들러를 등록하여 호출하면 됨

- 제거할 이벤트 핸들러가 변수나 자료구조에 저장되어 있어야 함
  - 참조를 모르면 제거할 수 없음
    - 무명 함수를 이벤트 핸들러로 등록한 경우 제거할 수 없음
      - arguments.callee를 사용할 수도 있지만 최적화를 방해하므로 strict mode에서 사용 금지

### 이벤트 핸들러 프로퍼티로 등록한 이벤트 핸들러 제거

이벤트 핸들러 프로퍼티에 null을 할당하면 됨

## 이벤트 객체

이벤트가 발생하면 이벤트 객체가 동적으로 생성 됨

- 생성자 함수에 의해 생성된 것
  - 따라서 이벤트 객체는 프로토타입 체인의 상속을 받는다.
    - target 프로퍼티는 Event.prototype으로부터 상속받은 것

## 이벤트 전파

이벤트 객체는 target을 중심으로 DOM 트리를 통해 전파된다.

target : 이벤트가 발생한 타깃

currentTarget : 이벤트 핸들러

### 이벤트 전파 단계

캡처링 단계는 addEventListener 메서드 방식으로 등록한 이벤트 핸들러만 캐치 가능

- capturing phase : 이벤트가 window에서 target 방향으로 전파
- target phase : 이벤트가 target에 도달
- bubbling phase : 이벤트가 target에서 window 방향으로 전파

## 이벤트 위임

이벤트는 이벤트를 발생시킨 이벤트 타깃은 물론 상위 DOM 요소에서도 캐치할 수 있다.

- 이벤트 전파가 가능하므로

이벤트 위임을 통해 여러 개의 하위 DOM 요소에 각각 이벤트 핸들러를 등록하는 대신 하나의 상위 DOM 요소에 이벤트 핸들러를 등록할 수 있다.

- 여러 개의 하위 DOM 요소에 이벤트 핸들러를 등록할 경우
  - 성능 저하의 원인
  - 유지 보수에도 부적합한 코드
- 이벤트에 반응이 필요한 DOM 요소에 한정하여 이벤트 핸들러가 실행되도록 이벤트 타깃을 검사할 필요가 있다.

## 커스텀 이벤트

이벤트 생성자 함수를 호출하여 명시적으로 생성한 이벤트

- 새로운 타입의 이벤트는 CustomEvent 생성자 함수를 호출
  - foo처럼 기존에 없는 이벤트의 경우 new CustomEvent(’foo’);
- 기존에 있는 타입의 이벤트는 해당 타입의 생성자 함수를 호출
  - click은 new MouseEvent(’click’)

### custom event dispatch

생성된 커스텀 이벤트는 dispatchEvent 메서드를 통해 이벤트를 발생시킨다.

- dispatchEvent 메서드는 이벤트 핸들러를 런타임에 동기 처리방식으로 호출
  - 따라서 이벤트를 디스패치하기 이전에 커스텀 이벤트를 처리할 이벤트 핸들러를 등록해야 함
- 일반적으로 이벤트 핸들러는 비동기 처리 방식으로 동작

### isTrusted

이벤트 생성자 함수로 생성한 커스텀 이벤트는 isTrusted 프로퍼티의 값이 언제나 false

커스텀 이벤트가 아닌 사용자의 행위에 의해 발생한 이벤트에 의해 생성된 이벤트 객체의 isTrusted 프로퍼티의 값은 언제나 true

---

동일한 이벤트만 캐치한다

- keyup, keydown 있는데 keyup 이벤트가 발생하면 keyup 이벤트만 캐치한다.
  - 둘 다 KeyboardEvent 객체를 생성하지만 보는건 동일한 이벤트만

---

# 41장 타이머

## 호출 스케줄링

타이머 함수를 사용하여 함수 호출을 예약하는 것

## 타이머 함수

ES 사양에 정의된 빌트인 함수가 아님

브라우저와 Node.js 환경에서 전역 객체의 메서드로 타이머 함수를 제공

- 타이머 함수는 호스트 객체다

## 디바운스

일정 시간 동안 이벤트가 더 이상 발생하지 않으면 이벤트 핸들러가 한 번만 호출하는 기법

- resize 이벤트 처리
- input 요소에 입력된 값으로 ajax 요청하는 입력 필드 자동완성
- 버튼 중복 클릭 방지

## 스로틀

일정 시간 단위로 이벤트 핸들러가 호출되도록 호출 주기를 설정하는 기법

- scroll 이벤트 처리
- 무한 스크롤 구현
