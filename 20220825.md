# 20220825목

## 일반 함수는 화살표 함수를 써라

일반 함수를 함수 선언문이나 표현식으로 쓰지마라✅

- constructor라서 프로토타입 생성한다✅
  - 프로토타입도 메모리를 먹는다.✅
- 일반 함수나 콜백 함수로는 화살표 함수를 써라✅
  - non-constructor라서 프로토타입 생성 안 한다.✅
  - this 불일치 문제 해결을 위해 나온거니 콜백으로 적극 사용

## 메서드는 ES6 메서드를 써라

메서드로 화살표 함수를 쓰는 건 좋지 않다. this가 꼬인다. ✅

대신 메서드 내부에서 화살표 함수를 사용하는 건 괜찮다.✅

ES6 메서드를 써야하는 이유

- 불필요한 퍼포먼스 낭비 제거✅
  - 프로토타입 객체 생성
  - 생성자 함수로 동작
- 수퍼클래스의 메서드 참조✅

## this는 메서드에서만 의미가 있다.✅

this는 프로퍼티나 메서드를 참조할 때 사용한다. 일반 함수 내에서는 의미가 없다.

## this가 일반 함수에서도 유효한 이유

일반 함수로 호출될지, 메서드로 호출될지 모른다.✅

- ES6 이전에는 일반 함수가 메서드로 쓰였다.
  - this는 메서드 내에서 호출자를 참조할 때 사용되므로

## 함수는 한 가지 일을 하는게 가장 이상적이다.

한 줄이 여러 줄 보다 가독성이 좋다

- 한 줄로 된, 한 가지 일을 하는 화살표 함수가 이상적
  - 이상은 이상일 뿐, 현실과 타협 필요

## ES6 부터는 유사배열객체를 안 쓰고 배열을 쓰는 추세다.

arguments는 유사배열객체고 Rest 파라미터는 배열이다.

- Rest 파라미터로 가변인자함수 구현 가능하다.

## 배열은 같은 타입의 값들로 이루어져야 의미가 있다.✅

```jsx
[1, '2', true]
이러면 100% 객체다. 배열의 의미가 없다.
현실적으로 알고리즘 말고는 쓸 일이 없다.

[1, 2, 3]
이렇게 해야 배열의 의미가 있고, 훨씬 빠르다.
```

## 프론트엔드의 주요 역할

데이터는 화면에 그리는 용도로 쓰인다. 즉 데이터는 렌더링의 재료다.

1억개의 데이터가 있더라도 모두 가져오는 게 아니고 화면에 보여줄 만큼만 가져오면 된다.

프론트엔드가 하는 일의 핵심은

- 서버에서 데이터를 가져와 렌더링하거나✅
- 혹은 서버로 데이터를 보내는 일이다.✅

## 배열 고차 함수와 배열 일반 메서드의 차이

- 인수로 콜백을 받느냐 안 받느냐의 차이.

고차함수를 써라.

## 배열이든 객체든 원본 훼손 X, 불변성을 유지해야 한다.

원본을 바꾸지 말고 주소값이 바뀐, 새로운 배열이나 객체를 재할당해야 한다.

## 가장 좋은 건 map, filter이고 reduce는 최후의 수단✅

배열 중에서 가장 중요한 메서드는 map과 filter다.

- reduce는 최후의 수단이다.
  - 가독성이 좋지 않다.✅
  - reduce로 가능한 대부분이 map과 filter로 가능하다.

map, filter, reduce는 내부 동작 원리를 다 알아야 한다.

## map, filter, reduce는 새로운 배열을 반환한다.

orig을 바꾸는 건 외부 상태를 바꾸는 것이다.

- 전형적인 비순수 함수

map, filter, reduce는 원본 배열을 바꾸지 않고 새로운 배열을 반환한다.

- 순수 함수

```jsx
const orig = [1, 2, 3];
const res = orig.map((v) => v); // [1, 2, 3]

res === origl; // ?
```

## 배열의 요소가 객체일 경우 주의

배열의 각 요소가 객체일 경우 map, filter, reduce로도 객체를 바꿀 수 있다.

- 이는 곧 원본 배열을 바꾸는 것이다.
- 콜백 함수 내에서 요소 객체를 복사해서 사용해야 한다.
