# 20220921수

## 호출 연산자의 동작 ✅

함수가 호출되면 내부 슬롯 [[Call]]이 호출된다.

- 내부 슬롯 [[Call]]이 호출되기 위해서는 호출 연산자 ()를 만나야 함
- 호출 연산자가 제대로 동작하기 위해서는 피연산자가 함수 객체로 평가되어야 함
  - 피연산자가 함수 객체로 평가되지 않으면 호출 불가능한 식별자로 호출된 것
    → TypeError가 발생한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bd0b9289-167b-441f-a7fb-082d312748b0/Untitled.png)

## 상속 받은 프로퍼티들은 모두 [[Prototype]]에 담겨있다. ✅

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5a4b0ebc-bbbb-4e7b-860d-d3d64f2cd867/Untitled.png)

## 리터럴은 생성자 함수가 만드는 게 아니다. ✅

추상연산 OrdinaryObjectCreate가 만든다.

- 그럼에도 생성자 함수와 연결되는 이유
  - 생성자 함수는 프로토타입과 항상 쌍으로 존재하기 때문이다.

## 순회 vs 열거 ✅

[1, 2, 3]이라는 배열을 for문으로 도는건 ‘순회'라고 한다.

순회는 ‘순서'가 있다는 것이 중요하고 열거는 ‘순서'에 의미가 없다.

- 배열은 순서에 의미가 있으므로 순회라고 하고, 객체는 순서에 의미가 없으므로 열거라고 한다.
- 객체는 이름에 의미가 있고, 배열에는 이름이 없다.
- 배열은 인덱스고, 객체는 이름이 의미가 있는 프로퍼티 키를 가진다.

## 열거를 못하게 하는 이유 ✅

(enumerable: false)열거를 못하게 하는 이유는 우리가 알아도 의미가 없기 때문이다.

- 불필요한 프로퍼티들을 열거하면 엔진은 불필요한 일을 하게 된다.

## 유사 배열 객체 ✅

유사 배열 객체는 설계 미스라고 판단된다.

- 특히나 ES6부터 Rest 파라미터가 나오면서 유사 배열 객체의 의미는 더욱 퇴색되었다.
- 배열보다 객체가 나은 점은 메서드를 자유자재로 넣을 수 있다는 것인데, 필요한 대부분의 메서드는 배열 메서드로 해결이 가능하다.
- 배열 메서드로 대부분의 필요한 순회가 가능하므로, 순회 가능한 유사 배열 객체는 쓸 일이 많이 없다.
- 화살표 함수에서는 자체 arguments 객체가 없다.
  - 가변 인자 함수는 Rest 파라미터를 사용하면 된다.
