# 자바스크립트 딥다이브 4~8장

## 변수란 무엇인가? 왜 필요한가?

```jsx
10 + 20;
```

자바스크립트 엔진이 위 코드를 계산(평가) 하려면 먼저 10, 20, +라는 기호(리터럴과 연산자)의 의미를 알고 있어야 하며, 10 + 20이라는 표현식의 의미도 해석(파싱)할 수 있어야 합니다.

자바스크립트 엔진이 10 + 20이라는 식의 의미를 해석하면 + 연산을 수행하기 위해 먼저 + 연산자의 좌변과 우변의 숫자 값, 즉 피연산자를 기억합니다.

컴퓨터는 `CPU`를 사용해 연산하고, `메모리`를 사용해 데이터를 기억합니다.

## 메모리

메모리는 데이터를 저장할 수 있는 메모리 셀의 집합체입니다.

메모리 셀 하나의 크기는 1바이트(8비트)이며, 컴퓨터는 메모리 셀의 크기, 즉 1바이트 단위로 데이터를 저장하거나 읽어들입니다.

메모리에 저장되는 데이터는 데이터의 종류(숫자, 텍스트, 이미지, 동영상 등)와 상관없이 모두 `2진수`로 저장됩니다.

## 메모리 주소를 통해 값에 직접 접근할 수 없다.

위 10 + 20의 연산 결과인 30은 재사용할 수 없습니다.

연산 결과를 재사용하고 싶다면 메모리 주소를 통해 연산 결과 30이 저장된 메모리 공간에 직접 접근하는 것 외에는 방법이 없습니다.

하지만 메모리 주소를 통해 값에 직접 접근했다가 실수로 운영체제가 사용하고 있는 값을 변경하면 치명적인 오류가 발생할 수 있습니다. 따라서 자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않습니다.

혹시나 직접적인 메모리 제어를 허용하더라도 값이 저장될 메모리 주소는 코드가 실행될 때 메모리의 상황에 따라 임의로 결정됩니다. 즉 런타임마다 동일한 코드를 실행해도 값이 저장될 메모리 주소는 계속 임의로 바뀝니다.

이처럼 코드가 실행되기 이전에는 값이 저장된 메모리 주소를 알 수 없으며, 알려 주지도 않습니다.

## 값을 재사용하기 위해 변수를 사용해야 한다.

변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말합니다.

## 변수의 선언

var 키워드를 사용한 변수 선언은 선언 단계와 초기화 단계가 동시에 진행됩니다. 런타임 이전에 변수 이름이 등록되고 동시에 암묵적으로 undefined를 할당해 초기화합니다.

일반적으로는 변수가 선언된 ‘이후' 최초로 값을 할당하는 것을 초기화라고 합니다.

만약 초기화 단계를 거치지 않으면 확보된 메모리 공간에는 이전에 다른 애플리케이션이 사용했던 값이 남아있을 수 있습니다. 이러한 값을 쓰레기 값이라 합니다. 따라서 메모리 공간을 확보한 다음, 값을 할당하지 않은 상태에서 곧바로 변수 값을 참조하면 쓰레기 값이 나올 수 있습니다.

## 변수 선언의 실행 시점과 변수 호이스팅

변수의 선언 시점은 런타임이 아니라 그 이전에 소스코드 평가 단계에서 먼저 실행됩니다. var 키워드의 경우 런타임 이전에 변수 선언과 동시에 undefined로 값이 초기화되기 때문에 선언문 이전에 변수를 참조해도 참조 에러가 발생하지 않고 undefined가 참조됩니다.

이처럼 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅이라 부릅니다.

## 값의 재할당

변수에 값을 재할당하면 기존 값은 식별자와의 연결이 끊어져 더이상 필요하지 않게 됩니다. 이러한 불필요한 값들은 가비지 콜렉터에 의해 메모리에서 자동 해제됩니다. 단 메모리에서 언제 해제될지는 예측할 수 없습니다.

가비지 콜렉터는 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 어떤 식별자도 참조하지 않는 메모리 공간을 해제하는 기능을 말합니다.

자바스크립트 같은 `매니지드 언어`는 메모리의 할당 및 해제를 위한 메모리 관리 기능을 언어 차원에서 담당하고 개발자의 직접적인 메모리 제어를 허용하지 않습니다. 이러한 매니지드 언어는 개발자의 역량에 의존하는 부분이 상대적으로 작아져 어느정도 일정한 생산성을 확보할 수 있다는 장점이 있지만, 어느정도의 성능 면에서 손실은 감수할 수밖에 없습니다.

---

## 표현식인 문과 표현식이 아닌 문

문(statement)은 프로그램을 구성하는 기본 단위이자 최소 실행 단위입니다.

표현식인 문과 표현식이 아닌 문을 구별하는 가장 간단하고 명료한 방법은 변수에 할당해 보는 것입니다. 표현식인 문은 값으로 평가되므로 변수에 할당할 수 있습니다.

```jsx
const func = function log(value) {
  console.log(value);
};
```

그럼 위의 함수 선언문은 변수에 할당 가능하므로 표현식인 문일까요?

아닙니다.❌

위 변수에 할당된 것은 함수 선언문이 아닌 ‘함수 리터럴'입니다.

함수 리터럴과 함수 선언문은 겉보기엔 비슷하지만 분명히 다릅니다.

|                | 함수 선언문 | 함수 리터럴 |
| -------------- | ----------- | ----------- |
| 변수 이름 생략 | 불가능      | 가능        |
| 변수에 할당    | 불가능      | 가능        |
| 표현식인 문    | 아님        | 맞음        |

즉, 위 코드에서 변수에 할당된 것은 얼핏보면 함수 선언문이라고 생각할 수 있지만, 함수 선언문은 표현식이 아닌 문입니다. 따라서 변수에 할당할 수 없습니다. 저 녀석은 함수 리터럴입니다!

---

## 데이터 타입의 필요성

데이터 타입은 왜 필요한 걸까요? 값은 메모리에 저장하고 참조할 수 있어야 합니다. 메모리에 값을 저장하려면 먼저 확보해야 할 메모리 공간의 크기를 결정해야 합니다. 다시 말해, 몇 바이트의 메모리 공간을 사용해야 낭비와 손실 없이 값을 저장할 수 있는지 알아야 합니다.

예를들어 문자 하나당 2바이트의 메모리 공간이 필요하고, 숫자값은 8바이트의 메모리 공간이 필요하다고 가정해봅시다. 숫자값을 저장해야 하는데 2바이트의 메모리 공간을 할당하면 숫자값을 저장할 수 있을까요?

반대로 ‘a’라는 문자열이 저장된 메모리 공간을 참조하고 싶은데 8바이트의 메모리 공간을 참조했다고 가정해봅시다. 그럼 읽힌 값은 그냥 ‘a’일까요?

추가적으로 아래 코드를 봅시다.

```jsx
const value = 65;
```

65라는 숫자값은 메모리 공간에 0100 0001이라는 2진수로 저장되어 있습니다. 해당 값을 숫자로 해석하면 65지만 문자열로 해석하면 ‘A’가 됩니다.

위에 설명한 다양한 이유들로 인해 데이터 타입은 꼭 필요합니다!

- 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
- 값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해
- 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해

## 동적 타이핑

자바스크립트는 변수를 선언할 때 타입을 선언하지 않습니다. 자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정됩니다. 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있습니다.

값은 타입을 갖습니다. 하지만 앞서 언급한 것 처럼 타입을 갖지 않습니다. 현재 변수에 할당되어 있는 값에 의해 변수의 타입이 동적으로 결정된다고 표현하는 것이 더 적절합니다.

따라서 변수는 값의 변경에 의해 타입이 언제든지 변할 수 있으므로, 값을 확인하기 전에는 타입을 확신할 수 없습니다. 더욱이 자바스크립트는 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동으로 변환되기도 합니다. 결국 동적 타입 언어는 유연성은 높지만 신뢰성은 떨어집니다.

---

## Object.is 메서드

```jsx
-0 === +0; // true
Object.is(-0, +0); // false
NaN === NaN; // false
Object.is(NaN, NaN); // true
```

[Object.is](http://Object.is) 메서드는 위 코드에 대해서 좀 더 정확한 비교 결과를 반환합니다 그 외에는 일치 비교 연산자(===)와 동일하게 동작합니다.

## 블록문

블록문은 0개 이상의 문을 중괄호로 묶은 것을 말합니다. 자바스크립트는 블록문을 하나의 실행 단위로 취급합니다. 블록문을 단독으로 사용해도 되지만, 일반적으로는 제어문이나 함수를 정의할 때 사용합니다. 블록문은 자체 종결성을 갖기 때문에 블록문의 끝에는 세미콜론을 붙이지 않습니다.

## break와 continue

break문은 레이블 문, 반복문 또는 switch문을 탈출할 때 쓰입니다.

continue문은 반복문에서 코드 블록의 실행을 현 지점에서 중단하고 반복문의 ‘증감식’으로 실행 흐름을 이동시킵니다.
