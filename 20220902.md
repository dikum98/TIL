# 20220902금

## 에러(error)와 예외(exception)

에러는 단순하게 오류뜨는거고 예외는 우리가 기대한대로 동작하지 않는 것

예외는 NaN같은거.

- 에러를 발생시키지 않으려고
- 1 \* n (알고보니 문자열인 식별자) ⇒ NaN 발생
  - 처음엔 let n = 1 이런 숫자였겠지만, n = ‘a’ 재할당에 의해 1 \* n ⇒ NaN 과 같은 예외가 발생
    - 결국 재할당은 안 좋은 것이다.
  - 변수에 타입이 없어서 발생 (동적 타입)
    - 동적 타입이 위험, 타입스크립트 쓰자
  - 에러가 아닌 NaN은 위험하다. 나도 모르는 곳에서 문제발생 가능
    - 결국 예외보다는 에러가 좋다.
      - 그래야 문제를 빨리 캐치하고 해결 가능

### 에러를 발생시켜라

예외 상황에서 에러를 던지지 않으면 의도치 않은대로 동작하고, 여기서 캐치하지 못하면 나중에 더 큰 문제가 발생

- 예외 상황에서 에러를 던지자.
  - 에러는 구체적일수록 좋다.
    - abc라는 에러가 있다면 에러 생성자 함수를 상속받아서 클래스를 만들든지 해라
- 에러는 호출자 방향으로 전파되므로, 한 곳에서 잡을 수 있다.
- await가 나오면서

## 호출자(caller)란

현재 실행중인 실행 컨텍스트가 caller다

전역에 foo함수가 있고 foo함수 내부에 bar함수가 있으면 bar 함수의 호출자는 foo이고 foo함수의 호출자는 전역이다.

- 비동기의 경우 호출자가 없다.
  - 태스크 큐에서 기다리다가 콜스택이 비었을 때 호출되므로
  - await은 비동기를 동기처럼 쓸 수 있게 해줌
    - 따라서 await과 try catch문을 사용해서 에러를 잡아야 한다.

---

## 모듈

### 모듈이 없던 시절

자바스크립트는 웹사이트의 보조적인 기능을 위해 태어났으므로 ES5까지는 모듈이 없었다.

- 모듈 없으면 파일 1000개라면 script 1000개 달아줘야 함. + 실행 순서도 맞춰서
- 서로 다른 파일이 동일한 전역 스코프를 공유
  - var로 선언한 전역 변수가 의도치 않게 재할당 되는 문제가 발생

### 모듈의 등장

모듈을 어떻게 나눌 것인가? (+ 폴더 관리)

- 기능별로 나눈다
- 화면별로 나눈다

### 모듈 스코프

모듈은 모듈 스코프 혹은 파일 스코프를 가진다.

- 전역이 존재하지 않는다.
- 각각의 모듈은 서로 참조할 수 없다.
- 정보 은닉이 가능하다.

### 모듈은 클로저

```jsx
// 모듈
const a = 1;

const foo = () => {
  console.log(a);
};

export default foo;
```

다른 모듈에서 foo를 가져다 쓰면 foo는 클로저가 된다.

- a는 해당 모듈 내에서만 볼 수 있다.
  - 다른 모듈에서 a를 참조할 수 없다.
  - private과 흡사함

### export의 종류

default

- 하나만 export 가능
- 기본적으로 default 사용

named

- 여러 개 export 가능
- default와 named 섞어써도 됨

### export 얼마나?

적으면 적을수록 좋지만 20개 정도까지 export 하는 건 괜찮다.

---

## Babel

구형 브라우저에서 지원하지 않는 최신 문법을 하위 문법으로 변환시켜주는 트랜스파일러

- 표준으로 봐도 무방

## FE 개발자의 역량

빠른 학습 능력

- 기본기가 탄탄해야 새로 배워도 빨리 배운다.
- 공식 사이트 도큐먼트를 읽어야 한다. (티스토리 X, 벨로그 X)
  - 만든 사람이 쓴 글이다.
  - 진득하게 읽어볼 필요가 있다.
    - 너무 길면 최소한 get started라도 읽어본다.
    - concepts는 꼭 읽어보자
    - 번역기 돌려서라도
  - 최소 5번은 읽어야 한다.

## CORS

FE에서는 할 일이 없다. 백엔드 (서버)에서 CORS를 allow 해줘야 한다.

- 노드에서 CORS라는 라이브러리 깔아서 한 줄로 해결 가능
- 혹은 프록시로 해결

---

## MVC라는 이름은 중요하지 않다

어떤 하나의 패턴으로 통일한다는게 중요

- 여러 사람이 하나의 통일된 아키텍처를 따르면 생산성이 증가
- 협업의 근본적인 목적은 생산성의 향상
  - 이러한 측면에서 검증된, 통일된 아키텍처를 쓰는게 중요
  - 아키텍처에 대한 이해가 선결되면 프레임워크를 잘 사용할 수 있음
    - ex) 리액트에서 이야기하는 state란 무엇인가
    - ex) 리렌더링이란 무엇인가? 어떻게 구현해야 하는가?
    - 사용법만 익히는건 의미가 없음

![20220902.png](./image/20220902.png)

액션에 따라 해야 할 일을 컨트롤러가 명확히 ‘시킴’

화살표가 양방향으로 되면 복잡도가 배로 증가함

- 화살표는 함수 호출을 의미.
- event는 event가 발생하면 이벤트핸들러가 호출됨을 의미

컨트롤러는 이벤트 핸들러를 의미

모디파이는 모델을 변경하는 함수를 호출한다는 의미

- ex) addTodo, removeTodo 호출

state(모델): 뷰에 영향을 주는 데이터

모든걸 다 모델로 만들 필요는 없다

- ex) 지역 변수를 다 모델로? X

### 상태 관리

이러한 state들을 관리하는 것을 리액트에서 상태 관리라고 한다.

리액트에서는 state 관리만 하면 알아서 바꿔주고 업데이트하고 리렌더링 알아서 시켜줌

애플리케이션을 만드는 건 잔기술이 아니고 숲의 큰 흐름을 이해할 수 있어야 함

돌아가는데 급급하지말고, 어떻게 만들어야 좋을지 생각하는 개발자가 돼라

---

# 43장 Ajax

## Ajax란

자바스크립트를 사용하여 브라우저가 서버에게 비동기 방식으로 데이터를 요청하고, 서버가 응답한 데이터를 수신하여 웹페이지를 동적으로 갱신하는 프로그래밍 방식

- Ajax는 브라우저에서 제공하는 Web API인 XMLHttpRequest 객체를 기반으로 동작

### XMLHttpRequest란

웹 브라우저와 웹 서버 간의 데이터 교환을 하기 위한 객체 폼의 API

- XHR 객체는 HTTP 비동기 통신을 위한 메서드와 프로퍼티를 제공
- 이 객체는 브라우저에 의해서 제공됨
  - 호스트 객체

## 전통적인 통신 방식

이전 웹 페이지와 차이가 없어서 변경할 필요가 없는 부분까지 포함된 완전한 HTML을 서버로부터 매번 다시 전송받음

- 불필요한 데이터 통신이 발생
- 변경할 필요 없는 부분까지 처음부터 다시 렌더링
  - 화면 전환이 일어나면 순간적으로 깜빡이는 현상이 발생

클라이언트와 서버와의 통신이 동기 방식으로 동작함

- 서버로부터 응답이 있을 때까지 다음 처리는 블로킹 됨

## Ajax의 통신 방식

변경하는데 필요한 데이터만 서버로부터 전송받음

- 불필요한 데이터 통신이 발생하지 않음
- 불필요한 렌더링이 발생하지 않음
  - 화면이 순간적으로 깜빡이지 않음

클라이언트와 서버와의 통신이 비동기 방식으로 동작

- 서버에게 요청을 보낸 이후 블로킹 발생 X

## JSON

JavaScript Object Notation의 약자

- 클라이언트와 서버 간의 HTTP 통신을 위한 텍스트 데이터 포맷
  - 자바스크립트에 종속되지 않은 언어 독립형 포맷
  - 대부분의 프로그래밍 언어에서 사용 가능
- 객체 리터럴과 유사하게 키와 값으로 구성된 순수한 텍스트

### JSON.stringify

객체를 JSON 포맷의 문자열로 변환

- 클라이언트가 서버로 객체 혹은 배열을 전송하려면 객체를 문자열화(serializing) 해야 함

### JSON.parse

JSON 포맷의 문자열을 객체로 변환

- 서버로부터 클라이언트에게 전송된 JSON 데이터를 사용하려면 객체화(deserializing) 해야 함
