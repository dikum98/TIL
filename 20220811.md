# 오늘 배운 것

### map 메서드는 순수 함수인가?
map 메서드는 비순수 함수입니다. 외부의 상태 즉, map 메서드를 호출하고 있는 배열에 의존하고 있기 때문입니다. 앞의 호출자 배열은 map 메서드의 외부 상태라고 볼 수 있습니다.

```jsx
var res = [1, 2, 3].map(function(item) {
  return item * 2;
})

console.log(res);
```

### 그렇다면 순수 함수란?
순수 함수는 아래와 같은 특징을 갖습니다.
- 외부 상태를 변화시키지 않는다.
- 외부 상태에 따라 함수의 반환값이 달라지지 않는다.
- 외부 상태를 참조하지 않는다.
- 외부 상태를 아예 처다보지 않는다.

```jsx
function add(a, b) { return a + b } 이건 순수함수다.
근데
var x = 10;
function add(a, b) { return a + b + x } 이건 비순수함수다.
위에 x가 바뀌면 결과도 바뀌기 때문에.
```

이를 다르게 생각하면 모든 것을 순수 함수로 만드는 일은 불가능에 가깝습니다. 모든 것을 순수 함수로 만들어야지! 라기 보다는, 가능하면 순수함수를 지향하는 것이 목표라고 할 수 있습니다.

### 프로그램의 본질은 어쩌면 부수효과에 있다!
예를 들어 addEventListener의 경우 콜백함수는 호출자에 의존합니다. 호출자에 따라 값이 달라지는 부수 효과가 있습니다.

부수효과를 일으키지 않고 어떠한 기능을 만들어 낸다는 건, 거의 불가능에 가깝습니다. 따라서 프로그램의 본질은 어쩌면 <code>부수효과</code>에 있다고 볼 수 있습니다. 그렇다면 함수형 프로그래밍의 컨셉은 어떨까요? 모든 애플리케이션에서 함수형을 추구하는 것은 좋지만, 부수효과를 피할 수는 없습니다. 그렇다면 어떻게 접근해야 할까요?

바로 부수효과가 있는 부분과, 부수효과가 없는 부분을 쪼갤 필요가 있습니다. 그 이유는 <code>순수함수의 테스트 용이성</code>에 있습니다.

지금 시점에서 중요한 건, 어떤게 순수함수이고 어떤게 비순수함수인지를 구분할 줄 아는 것이 중요합니다.

```jsx
function add(a, b) { return a + b }; 얘는 테스트가 용이하다.
function add(a, b) { return a + b + x }; 얘는 앞에 순수함수에 비하면 테스트가 어려워진다.
```

### 일급 객체
일급 객체란 인수로 전달할 수 있고, 반환할 수 있고, 여러 자료 구조에 값으로 담을 수도 있는 형태를 의미합니다. 이러한 맥락에서 함수는 일급 객체입니다. 함수가 일급 객체라는 말은 곧 함수형 프로그래밍이 가능한지 아닌지에 대한 의미를 내포합니다.

### 콜백 함수
콜백 함수라는 개념은 함수형 프로그래밍의 가장 기본이 되는 것입니다. 콜백 함수가 값이기 때문에 매개변수에 담을 수 있는 것입니다. 

### 무엇이 콜백 함수인가?
우리가 만드는 모든 함수들은 이벤트 핸들러 내에서 사용됩니다. 따라서 우리가 만드는 모든 함수들은 비 순수적인 함수 안에서 호출이 됩니다. 근데 addEventListener의 인수로 들어오는 함수는 콜백 함수가 아니라 이벤트 핸들러라고 부릅니다. 콜백 함수는 고차 함수에 의해 자체적으로 호출될 수 있어야 합니다. addEventListener는 브라우저에 의해 호출되기 때문에 콜백 함수가 아닙니다.

마찬가지로 setTimeout의 인수로 들어오는 함수도 콜백 함수라고 하지 않습니다. 이 또한 마찬가지로 브라우저가 호출하기 때문입니다.

### 콜백 함수를 사용하는 이유?
콜백 함수를 왜 쓰느냐 묻는다면, 그 이유는 바로 공통되는 로직을 분리해서 <code>재사용</code>하기 위해서 입니다. 변하지 않는 공통 로직은 미리 정의해 두고, 경우에 따라 변경되는 로직을 추상화 하여 함수 외부에서 함수 내부로 전달할 수 있습니다.

A라는 함수와 B라는 함수에서 공통되는 것만 분리할 수 없을까? 라는 생각이 기저에 깔려 있습니다. 콜백 함수를 사용하는 이유와 같은 맥락에서 변수를 사용하는 이유는? 값을 재사용 하기 위해서, 함수를 사용하는 이유는? 공통 로직(코드 블럭)을 재사용하기 위해서 입니다.

### 그렇다면 왜 재사용이 중요한가?
재사용성이 중요한 이유는 매우 직관적입니다. 바로 생산성을 위해서 입니다. 좀 더 구체적으로 언급하자면, 유지보수를 쉽게 하기 위함입니다.

### 유지보수가 중요한 이유
코드를 고치면 테스트를 다시 해야합니다. 테스트를 다시 하는 건 쉽지 않은 일입니다. 코드가 여기저기 얽히고 설켜있는 스파게티라면, 내가 한 줄을 지웠을 때 어떤 파급 효과가 있을지 겁나기 마련입니다. 그러다보니 점점 더 기존 코드를 수정하지 않고 새로운 함수를 가져다 쓰게 됩니다.

객체 지향에서는 기존의 클래스를 고치기 겁이 나니까 새로운 클래스를 또 만듭니다. 비슷한 맥락에서 함수를 고치기 겁이 나니까 새로운 함수를 만들고, A, B, C, ... 여러 함수들이 연쇄적으로 생깁니다.

그럼 이 코드는 더이상 고치기 어려운 코드가 되고, 결국 모든 코드를 갈아엎어야 되는 상황이 발생합니다. 이러한 이유들 때문에 우리가 관심을 가져야 할 것은 <code>유지보수</code>입니다.

### 어떤 코드가 유지보수 하기 좋은 코드일까? 효율?? 아니 가독성!!
고치기 쉬운 코드란, 가독성이 좋은 코드입니다. <code>효율보다는 가독성</code>이 더 중요합니다. 효율이 아무리 좋아진다 하더라도 가독성이 좋은 코드를 쓰는게 더 중요합니다.

우리가 알고리즘을 풀 때 가독성이 좋은 코드 하나, 효율성이 좋은 코드를 또 하나 짜놓고 둘 다 돌려본다면 가독성이 좋은 코드는 테스트가 돌아가지 않는 경우도 있습니다. 그런 경우는 모수가 엄청나게 큰 경우입니다. 하지만 대부분의 경우에는 정말 미미한 시간의 차이가 날 뿐입니다. 따라서 가독성이 좋다고, 효율이 떨어진다고 해서 속도적인 측면에서 유의미한 차이를 보이지는 않습니다.

### var 키워드는 중복 선언이 된다? XXXX
중복 선언이라는 건 동일한 스코프에 동일한 식별자가 두 개라는 것인데, 이것은 불가능 합니다. 모던 자바스크립트 DeepDive의 208페이지에 나오는 "중복 선언이 가능하다"라는 말은, 재선언이 된다는 말이 아닙니다. 재할당이 일어날 뿐입니다.

```jsx
var a = 1;
var a = 10;
```

위 코드에서 실제로 동작하는 건 아래처럼 10이 재할당 될 뿐입니다. 재선언은 일어나지 않습니다.
```jsx
var a = 1;
var a = 10;
```

### var 키워드가 이처럼 동작하는 이유?
그렇다면 브랜든 아이크 씨는 왜 이러한 문법을 허용했을까요? var a = 1; 이라는 코드를 짜놓고 수 천, 수 만 줄의 코드를 작성한 다음 a라는 변수를 선언했음을 잊어버렸습니다. 그런 다음 var a = 10;이라는 선언을 또 했다고 생각해봅시다. 하지만 에러가 발생하지는 않습니다. 그 이유는 무엇일까요?

동일한 스코프에 동일한 식별자가 두 개 이상 존재하는 건 불가능하다고 앞서 이야기 했습니다. 이것이 var 키워드가 위처럼 동작하는 이유입니다.

자바스크립트에서는 파일이 하나이든, 100개의 파일이 있든 간에 한 파일처럼 동작하기 때문에 즉, 동일한 전역 스코프를 공유하기 때문에 다른 파일에 동일한 var 키워드 변수를 선언해도 결국엔 재할당이 일어날 뿐입니다. 동일한 식별자가 여러 개 있을 수 없으니까요.

### 모듈의 등장
위와 같은 불편함? 문제점을 개선하기 위해 <code>ES6</code>에서 <code>모듈</code>이라는 개념이 등장합니다. 코드가 모듈로써 동작한다는 건 파일별로 서로 다른 스코프 영역을 갖는다는 이야기, 즉 파일 스코프를 갖는다는 뜻입니다.

개발자로 살아가면서 파일을 여러 개로 쪼갤 일이 많을까요? 아니면 적을까요? 엄청 많습니다. 5만 줄 짜리의 코드가 한 파일에 존재한다면, 우리 개발 팀이 50명이라면, 그 하나의 파일로 작업을 어떻게 할 까요?

### 코드를 잘게 쪼개자
기본적으로 코드는 잘게 잘게 쪼갤 수록 좋습니다. 심지어 파일 하나에 함수 하나만 쓸 정도로요. 그럼 이런 의문점이 들 수 있습니다. "어, 그렇다면 script가 엄청 많아질텐데..." 맞습니다. 그럼 어떡할까요?

### WebPack의 등장
수없이 많이 쪼개진 script들은 모두 순서에 의미가 있습니다. 그런데 너무 복잡하죠. 이 순서를 일일이 정리하는 것도 어렵고, 이 순서에 따라 모듈 파일을 삽입하는 것도 불가능에 가깝습니다. 쪼개져 있는 모듈 파일들을 하나의 파일로 모으고싶지 않나요? 웹팩과 같은 번들러가 이를 가능하게 합니다! 쪼개진 파일들을 다시 뭉치도록 해주는 것이죠. 따라서 나중에 웹팩도 공부해 둘 필요가 있습니다.

### 식별자에 대한 이야기
식별자는 값을 식별하기 위한 고유한 이름입니다. 그런데 엄밀히 말하면 값이 아니라, 메모리 주소를 기억하고 있습니다. 다른 말로 변수 이름이라고도 부릅니다. 변수 이름보다는 식별자가 더 큰 범위의 개념입니다. 함수 이름도, 클래스도, 브라우저 url, 파일 이름도 식별자입니다. 굉장히 폭넓은 개념이죠.

식별자는 메모리 주소를 기억한다고 했습니다. 좀 더 엄밀히 말하면, 메모리 공간의 <code>선두 주소</code>를 알아야 합니다.

- 식별자는 메모리의 선두 주소를 기억하는 고유한 이름이다.

### 변수 초기화 시 할당되는 undefined는 몇 바이트일까?
정답은 "모른다" 입니다.

ECMAScript 사양서에 나와있지 않고, 브라우저 엔진마다 다릅니다. 모른다고 대답할 수 밖에 없고, 그것이 정답입니다.

### 메모리 셀의 크기는 왜 1바이트일까?
유의미한 최소 단위가 1바이트이기 때문에 메모리 셀은 1바이트로 약속되었습니다.

### 식별자가 메모리 주소를 어떻게 알까요?
식별자가 메모리 공간의 주소와 매핑되어 있다는 것은 책에서 배웠으니 알겠습니다. 근데 왜? 어떻게? 식별자와 메모리 주소가 매핑되는 것일까요?

"식별자가 메모리 주소와 매핑되어 있다"라는 정보 역시 메모리 공간에 저장되어 있습니다!

- 식별자는 사실 프로퍼티입니다. (스코프를 공부하면 알 수 있습니다.)

### 메모리 공간에 직접 접근할 수 없고 식별자를 통해야하는 이유는?
개발자에게 메모리 주소를 직접 알려주면, 사람은 실수를 하기 마련입니다. 주소에 잘못 접근하여 치명적인 오류가 발생할 수 있는 것이죠. 이러한 휴먼 에러(Human Error)를 발생시키지 않기 위해 사람이 이해할 수 있는 이름으로 메모리 공간을 가리키는 것이 바로 변수입니다. 따라서 변수는 메모리 셀을 가리키는 상징적 이름(Symbolic Name)입니다.

### 초기화란?
초기화는 변수를 선언하고 처음으로 값을 할당하는 것입니다.

아래 코드는 엄밀히 따지자면 100이라는 값이 변수 a에 재할당이 된 것이라는 점은 우리 모두 알고 있지만, 일반적으로는 초기화라고 이야기 해야 합니다. 변수에 undefined가 먼저 할당되는 것은 '암묵적인' 행위이기 때문이죠.
```jsx
var a = 100;
```

### 원시값은 왜 변하지 않는가?
효율성 때문입니다. 기존에 있던 값을 지우고 새로 쓰는 것 보다, 새로 할당한 값에 메모리 주소만 바꿔주는 것이 더 효율적입니다.

### 객체는 왜 변하는가?
저장의 효율성 때문입니다. 객체가 원시 값처럼 동작하면, 객체 내용을 바꾸는 순간 새로운 객체가 생성되어야 합니다. 하지만 그렇지 않죠. 해당 객체의 크기는 엄청 클 수 있습니다. 원시값에 비해 새로 생성하는 작업의 비용이 훨씬 크죠.

객체의 크기가 원시 값보다 훨씬 크기도 하고, 지금처럼 컴퓨터의 사양이 많이 올라온 상황에서는 무의미할 수 있지만, 예전에는 메모리 공간 자체가 귀하던 시절이었습니다. 그 때를 생각하면 객체가 바뀌는 이유를 알 수 있죠.

### 그럼 다시 객체도 원시 값처럼?
현대의 프로그래밍에서는 객체도 원시 값처럼 사용하려는 움직임이 있습니다. 이것이 바로 <code>함수형 프로그래밍</code>입니다.

예를 들어 map 메서드는 반환 값으로 아예 새로운 배열을 만들어서 반환합니다. 효율만 따지자면 기존 배열을 고치는 것이 더 빠릅니다. 그렇다면 map 메서드는 왜 새로운 배열을 만들어서 반환하는 것일까요? 함수형 프로그래밍에서 추구하는 외부 함수의 참조에 영향을 주지 않기 위해서 입니다!

push, pop, shift, unshift, sort 등과 같이 기존 배열을 변경하는 메서드는 초창기 자바스크립트에 나온 메서드들입니다. 반면에 map, filter, reduce등과 같이 ES5 이후에 추가된 메서드들은 외부 상태를 바꾸지 않는 메서드입니다.

### 어떤 배열 메서드를 사용할까?
외부 상태를 변경하는 메서드와, 변경하지 않는 메서드를 섞어서 사용하는 것은 좋은 습관이 아닙니다. 외부 상태를 변경하지 않는 메서드들을 사용하는 것이 좋습니다. 하지만 각 방법을 사용했을 때의 차이와 장단점을 알고있어야 합니다.

항상 사용하던 것만 쓰면 이건 왜 써야하고 저건 왜 쓰지 말아야 하고 그런 걸 모르면, 상황에 따른 판단을 잘 하지 못합니다. 결론적으로 좋은 코드를 짤 체력을 기를 수 없습니다.

### 제어문은 좋을까?
제어문에 대한 가치 판단이 필요합니다. 제어문이란 코드의 실행 흐름을 인위적으로 바꾸기 위함입니다. 그러나 이는 가독성을 해친다는 단점이 있습니다. 순차적으로 위에서 아래로 코드를 읽어 내려가는 것이 가독성에 더 좋기 때문이죠.

예를 들어 if문은 삼항 연산자보다 좋지 않습니다. 삼항 연산자는 위에서 아래로 코드 흐름을 읽는 가독성을 깨트리지 않습니다. 따라서 if문을 남용하는 것은 좋지 않습니다.

for문은 어떨까요? for문은 c언어에서 나온 문법입니다. for문의 () 내에도 문이 3개나 들어있기 때문에 가독성이 좋지 않습니다. 굳이 for문을 사용한다면 정해진 갯수만큼 처음부터 끝까지 다 도는 것이 가독성이 좋습니다.

### 처음부터 끝까지 다 도는 것이 좋다
따라서 map, filter, reduce와 같은 배열 고차 메서드를 사용하면, 내부적으로 for문을 도는데 처음부터 끝까지 다 돌게 됩니다. 중간에 continue문이나 break문을 사용할 수 없죠. 그 이유는 처음부터 끝까지 다 도는 것이 우리 인간 두뇌에 이해하기 가장 편하기 때문입니다.

알고리즘 테스트에서 for문을 사용하는 건 그나마 괜찮지만, 실무나 현업에서 for문을 사용하는 것은 지양하는 것이 좋습니다.

### if문이나 for문 같은 제어문 안에서 함수를 만들 수 있게 했던데, 왜요?
제어문 내부에서 함수를 정의하는 것은 문법적으로 좋지 않습니다. 예를들어 for문 내부에 함수를 생성하면 재사용을 위한다는 함수의 존재 이유에 위배됩니다. 함수가 계속 만들어지는 것이죠. 재사용을 위해서라면 한 번 만들어진 함수를 계속 써야하지, 동일한 함수를 반복적으로 계속 만드는 건 이상하죠?

### 얕은 복사와 깊은 복사
배열을 복사할 때 예전에는 slice를 사용했습니다.
하지만 spread operator가 등장하면서 배열을 복사할 때는 slice를 잘 쓰지 않죠.
```jsx
const arr = [1, 2, 3];
const copy = arr.slice();
```

### slice보다 spread operator를 써야하는 이유?
어떤 함수를 사용한다고 하면, 해당 함수의 인수를 알아야 하고 매개변수를 알아야 하고 함수 이름을 알아야 하지만, 그것 보다는 표현식을 쓰는 것이 더 쉽죠? 표현식을 사용하는 것이 실수를 줄인다는 측면에서도 더 좋습니다.

### 깊은 복사, 최신 문법에 추가해주면 안 되나요?
남발될 가능성이 있습니다. 엄청 커다란 객체를 계속 복사하는 경우 메모리가 가득 차게 되는 심각한 문제가 생길 수 있습니다. 따라서 라이브러리로 제공되는 것이 최선이라고 생각합니다. 다른 언어에서도 깊은 복사는 내장 문법이 아닌 라이브러리로 제공됩니다.

### 문맥에 따라 달라지는 평가들
함수 리터럴을 단독으로 사용하면 (값으로 평가되지 않으면) 함수 선언문이 되고, 소괄호 내에 사용하거나 변수에 할당되면 표현식으로 사용됩니다. 즉 문맥에 따라 평가가 달라집니다.

중괄호 { } 역시 값으로 평가될 수 있는지 아닌지 문맥에 따라 다르게 평가됩니다.

### 함수 표현식과 함수 선언문 중 어떤 것을 사용할까?
무엇을 써도 상관은 없지만, 하나를 일관적으로 사용할 것을 권장합니다.

### 타입 변환에 대하여
String이나 Number 등의 생성자 함수로 타입 변환을 하는 것은 좋지 않습니다. 타입 변환을 위해 존재하는 녀석들이 아니기 때문이죠. 함수의 목적에 맞게 사용하는 것이 당연히 좋겠죠?

명시적 타입 변환이나 암묵적 타입 변환도 뭐가 더 좋고 나쁘다, 그런 건 없습니다!

### switch 문의 사용
switch 문은 복잡하기 때문에 굳이 얘를 쓸 필요가 없다고 생각합니다.

### 즉시 실행 함수는 어떨 때 사용하나요?
예전에는 전역 변수를 오염시키지 않기 위해 사용했습니다. 하지만 요즘은 모듈이 등장했기 때문에 굳이 사용할 필요가 없습니다. 그보단, 한 번만 사용하고 버리고 싶을 때 혹은 클로저를 만들 때 주로 사용합니다.

### 프로퍼티는 식별자인가?
엄밀히 말하면 식별자는 아닙니다. 반대로, 식별자는 프로퍼티라고 앞서 말했습니다.

