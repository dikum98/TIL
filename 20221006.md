# 20221006 목

## 1번

- 영속적인 저장?
  - localStorage를 써야겠다..
- 사이드 내비게이션 상태를 언제 저장하고 언제 읽어 들이는 것이 효율적인지
  → 웹페이지를 떠날 때 저장, 들어올 때 읽어들이기

새로고침이나 페이지 이동 시에 트랜지션이 없어야 한다?

새로고침이나 페이지 이동 시에 트랜지션이 왜 발생하는지 몰랐는데 찬찬히 살펴보니까 알 수 있었다.

1. body에 preload 클래스가 없는 경우 → 모든 트랜지션이 발생 O
   1. 초기 렌더링시에도 스윽~ 트랜지션이 당연히 발생
2. body에 preload 클래스가 있는 경우 → 모든 트랜지션이 발생 X
   1. 트랜지션 다 none 해버렸으니까 아예 트랜지션 없음
3. body에 preload 클래스가 있는데 DOMContentLoaded 이벤트 발생할 때 preload 지운 경우
   1. css가 다 로드되기 전에 preload 클래스를 지웠으므로 1번과 마찬가지로 초기에도 트랜지션 스윽~ 발생
4. body에 preload 클래스 있고, load 이벤트 발생할 때 preload 지운 경우
   1. 초기 렌더링시에는 preload 클래스가 있어서 초기에 스윽~ 트랜지션 발생 안하다가 CSS 다 로드된 이후에 preload 지우니까 원하는 대로 동작

## 6번

6번에서 current rating의 값을 별점 컴포넌트에서 바꿔줄 수 있는데도 굳이 밖으로 방출해서 밖에서 바꿔줘야 하는 이유를 몰랐다.

근데 윤하님한테 이유를 들어보았다.

- 별점 컴포넌트의 역할이 아니다.
  - .current-rating은 별점 컴포넌트의 컨테이너(.star-rating-container) 범위 밖이다.
  - 그래서 app.js에서 해줘야 한다.
- 맞는 말인 것 같다..

## 8번

Nav.js와 NewsList.js에서 네비게이션 컴포넌트와 뉴스리스트 컴포넌트를 각각 생성하고, 네비게이션의 변화에 대한 참조를 프록시, 옵저버 패턴을 통해 캐치한다. 정확히는 모르지만 리액트에 프록시, 옵저버 패턴의 개념이 녹아있지 않을까 생각한다.

### intersectionObserver

intersectionObserver API는 루트 요소와 타겟 요소의 교차점을 비동기로 관찰하면서 콜백함수를 실행할 수 있게 함.

- 기존에 getBoundingClientRect 메서드를 쓸 때는 메인 스레드를 썼기 때문에 성능상 비교적 나빴음
  - 리플로우도 발생시킴
- 사이트는 요소의 교차를 관찰하기 위해 메인 스레드를 사용할 필요가 없어짐. 비동기적으로 실행.
  - 가시성 구분시 리플로우를 발생시키지 않음 → 교차 영역 관리 최적화

콜백을 호출할 수 있는 상황

- 대상 요소가 기기 뷰포트나 특정 요소와 교차할 때
- 옵저버가 최초로 타깃을 관측하도록 요청받을 때마다

# PP2 회고

- 프로그램을 짜기 위해 처음에 생각했던 로직이 있으면 그 로직대로 정면돌파 해야한다는 말씀을 체감함
  - 다르게 생각하면, 로직이 부실하면 코드에 변명이 가득하고 무너질 수 밖에 없다고 생각.
    → 내가 짠 코드임에도 불구하고 내가 설명을 못하는 상황 발생
  - 코드를 짜기 전에 로직에 대해 충분히 생각할 시간을 갖는게 중요한 것 같다.
    - 큰 틀을 잡고 디테일을 채워나가는 방식 (divide & conquer)
- 명확한 논리에 근거해서 코드를 짜자!
