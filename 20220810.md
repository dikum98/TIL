# 9장

## 타입 변환

타입 변환에는 암묵적 타입 변환과 명시적 타입 변환이 있습니다.

암묵적 타입 변환은 개발자의 의도와는 상관없이 표현식을 평가하는 ‘도중'에 자바스크립트 엔진에 의해 암묵적으로 변수에 할당된 값의 타입이 변환되는 것을 의미합니다.

참고로 값의 타입은 바뀔 수 있고 변수는 타입이 없습니다. 자바스크립트는 동적 타이핑 언어이기 때문입니다.

동적 타이핑 언어라는 말은, 변수가 선언되었을 때 타입이 지정되는 것이 아니라 변수에 값이 할당되었을 때 해당 값의 타입에 따라 변수의 타입이 지정된다는 의미입니다.

엄밀히 말하면 변수의 타입이 아니라 값의 타입에 따라 변수의 타입을 이야기 하는 것이기 때문에 변수는 타입이 없다고 이야기 합니다.

또 변수에 할당된 값의 타입이 변한다고 이야기 할 때, 메모리 공간에 할당된 값의 타입이 바뀐다는 의미보다는 타입이 바뀐 값이 새롭게 메모리 공간에 할당이 되고 해당 메모리 공간의 값을 매핑하기 위해 메모리 주소를 변수에 다시 매핑하는 것입니다.

### Optional Chaning

옵셔널 체이닝 ?. 연산자는 좌항의 피연산자가 null 혹은 undefined로 평가되는 경우 우항의 참조를 이어가지 않고 undefined를 반환하고 좌항의 피연산자가 null이나 undefined로 평가되지 않는 경우에는 우항의 참조를 이어갑니다. 흔히 객체의 참조를 이어가거나, 문자열의 길이를 참조하기 위해 사용합니다.

```jsx
const obj = null;
obj?.value; // undefined;

const str = '';

str?.length; // 0;
```

그렇다면 좌항의 피연산자가 null, undefined를 제외한 falsy값인 경우는 어떻게 될까요? 예를 들면 좌항의 피연산자가 0(+0, -0), ‘’, false, NaN일 경우에는 우항의 참조를 이어갈 수 있을까요? 네 가능합니다.

따라서 && 논리연산자의 경우에는 모든 falsy값의 경우 좌항의 피연산자를 그대로 반환하고 우항의 평가를 이어가지 않기 때문에 0이나 ‘’의 경우에도 우항의 피연산자의 참조를 이어가고 싶어도 그러지 못하는 반면에 옵셔널 체이닝 ?. 연산자는 좌항이 0이나 ‘’인 경우에도 우항의 피연산자의 참조를 이어갈 수 있습니다!

### Nullish coalescing

널 병합 연산자 ??는 좌항의 피연산자가 null 혹은 undefined로 평가되는 경우 우항의 피연산자를 참조하고, 그렇지 않은 경우에는 undefined를 반환합니다.
